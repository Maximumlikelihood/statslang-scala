\documentclass[mathserif,handout]{beamer}
%\documentclass{beamer}
\usetheme{Warsaw}
\usecolortheme{seahorse}
\usecolortheme{orchid}
\usepackage{amsmath,verbatim}
\usepackage{listings}
\usepackage[english]{babel}
\usepackage{movie15}
\setbeamercovered{transparent}

\newcommand{\Deltap}{\ensuremath{\Delta^{\!+}}}
\newcommand{\trans}{\ensuremath{{}^\mathrm{T}}}
\newcommand{\eps}{\varepsilon}
\newcommand*{\approxdist}{\mathrel{\vcenter{\offinterlineskip
\vskip-.25ex\hbox{\hskip.55ex$\cdot$}\vskip-.25ex\hbox{$\sim$}
\vskip-.5ex\hbox{\hskip.55ex$\cdot$}}}}

\lstdefinelanguage{myR}
{
   language=R,
   otherkeywords={read.table, set.seed, head},
   deletekeywords={url,codes, t, dt, Call, formula,Q, R, on,by,hat,is,
col, set,start,end,deltat,zip},
   sensitive=true,
   breaklines=true,
   morecomment=[l]{\#},
   morestring=[b]",
   morestring=[b]',
   basicstyle =\ttfamily\small,
   keywordstyle=\bfseries,
   showtabs=false,
   showstringspaces=false,
   literate= {~}{$\sim$}{2},
   numberstyle=\sffamily\scriptsize,
   stepnumber=2
 }


\begin{document}

\title[Scala --- RSS language shoot-out]{Scala as a platform for statistical computing and data science}
\author[Darren Wilkinson --- RSS, London, 21/11/14]{\textbf{\large Darren Wilkinson} \\
\alert{\url{http://tinyurl.com/darrenjw}}\\
School of Mathematics \& Statistics\\Newcastle University, UK}
\date{Statistical computing languages\\RSS, London, 21st November 2014}

\frame{\titlepage}

\section{Introduction}

\subsection{Outline}

\frame{
\frametitle{Talk outline}
\begin{itemize}
\item Requirements for a platform for statistical computing
\item Background: Scala, Java and the JVM
\item Functional programming, immutable data structures and parallelisation
\item Quick introduction to the Breeze scientific library
\item Examples: Monte Carlo and Linear regression
\item Wrap-up
\end{itemize}
}

\subsection{Requirements for a statistical computing platform}

\frame{
\frametitle{Feature wish list}
\scriptsize
It should:
\begin{itemize}
\item be a general purpose language with a sizable user community and an array of general purpose libraries, including good GUI libraries, networking and web frameworks
\item be free, open-source and platform independent, fast and efficient with a strong type system, and be statically typed with good compile-time type checking and type safety
\item have a good, well-designed library for scientific computing, including non-uniform random number generation and linear algebra
\item have reasonable type inference and a REPL for interactive use
\item have good tool support (including build tools, doc tools, testing tools, and an intelligent IDE)
\item have excellent support for functional programming, including support for immutability and immutable data structures and “monadic” design
\item allow imperative programming for those (rare) occasions where it makes sense
\item be designed with concurrency and parallelism in mind, having excellent language and library support for building really scalable concurrent and parallel applications
\end{itemize}
}

\section{Scala}

\subsection{Introduction}

\frame{
\frametitle{Scala}
\centerline{\includegraphics[width=\textwidth]{scala-website}}
\mbox{}\\
\bigskip
\alert{\url{http://www.scala-lang.org/}}
}

\frame{
\frametitle{History and background}
\begin{itemize}
\item The name Scala derives from ``Scalable Language"
\item It is a hybrid object-oriented/functional language
\item It supports both functional and imperative styles of programming, but functional style is idiomatic
\item It is statically typed and compiled --- compiling to Java bytecode to run on the JVM
\item It was originally developed by Martin Odersky, one of the original authors of the Java compiler, \texttt{javac} as well as Java generics, introduced in Java 5.
\item Development driven by percieved shortcomings of the Java programming langauge
\end{itemize}
}

\frame{
\frametitle{Scala usage}
\begin{itemize}
\item Scala is widely used in many large high-profile companies and organisations --- it is now a mainstream general purpose language
\item Many large high-traffic websites are built with Scala (eg. Twitter, Foursquare, LinkedIn, Walmart, Gilt, The Guardian, etc.) 
\item Scala is widely used as a Data Science and Big Data platform due to its speed, robustness, concurrency, parallellism and general scalability (in addition to seamless Java interoperability)
\item Scala programmers are being actively recruited by many high profile data science teams
\end{itemize}
}

\frame{
\frametitle{Static versus dynamic typing, compiled versus interpreted}
\small
\begin{itemize}
\item It is fun to quickly throw together a few functions in a scripting language without worrying about declaring the types of anything
\item But for any code you want to keep or share with others you end up adding lots of boilerplate argument checking code that would be much cleaner, simpler and faster in a statically typed language
\item For messing about prototyping, dynamic languages are attractive, but as a solid platform for statistical computing, they really don’t make sense
\item Scala has a strong type system offering a high degree of compile-time checking, making it a safe and efficient language
\item By maximising the work done by the compiler at build time you minimise the overheads at runtime
\item Coupled with type inference, statically typed code is actually more consise than dynamic code
\end{itemize}
}

\frame{
\frametitle{Functional versus imperative programming}
\begin{itemize}
\item Functional programming offers many advantages over other programming styles
\item In particular, it provides the best route to building scalable software, in terms of both program complexity and data size/complexity
\item Scala has good support for functional programming, including immutable named values, immutable data structures and for-comprehensions
\item Many languages are attempting to add functional features retrospectivly (eg. lambdas in C++, lambdas, streams and the option monad in Java 8, etc.)
\item Many new and increasingly popular languages are functional, and several are inspired by Scala (eg. Apple's Swift is essentially a cut down Scala, as is Red Hat's Ceylon)
\end{itemize}
}

\frame{
\frametitle{Using Scala}
\begin{itemize}
\item Scala is completely free and open source --- the entire Scala software distribution, including compiler and libraries, is released under a BSD license
\item Scala is platform independent, running on any system for which a JVM exists
\item Easy to install \texttt{scala} and \texttt{scalac}, the Scala compiler, but not really necessary
\item The ``simple build tool" for Scala, \texttt{sbt}, is all that is needed to build and run most Scala projects, and this can be bootstrapped from a 1M Java file, \texttt{sbt-launcher.jar}
\item All dependencies, including Scala library versions, and associated ``packages", can be specified in a \texttt{sbt} build file, and pulled and cached at build time --- no need to ``install" anything, ever --- most library/package versioning problems disappear 
\end{itemize}
}

\frame{
\frametitle{IDEs}
\begin{itemize}
\item There are several very good IDEs for Scala
\item In general, IDEs are much better and much more powerful for statically typed languages --- IDEs can do lots of things to help you when programming in a statically typed langauge which simply aren't possible when using a dynamically typed language
\item I use the ``Scala IDE" (\alert{\url{http://scala-ide.org/}}), which is based on Eclipse, but other possibilities, including IntelliJ (\alert{\url{https://www.jetbrains.com/idea/features/scala.html}}), which some prefer
\end{itemize}
}

\frame{
\frametitle{Reproducible research}
\begin{itemize}
\item Reproducible research is very important --- others should be able to run your code and reproduce your results
  \begin{itemize}
  \item Many within the statistics community have come to associate reproducible research with dynamic documents and literate programming --- nothing could be further from the truth!
  \item Can more-or-less guarantee that R code and documentation written with the latest trendy literate programming framework will not build and run in 2 years time (due to incompatible library and package version changes)...
  \end{itemize}
\item \texttt{sbt} build files specify the particular versions of Scala and any associated dependencies required, and so projects should build and run \alert{reproducibly} without issues for many years
\item Standard code documentation format, Scaladoc \alert{\url{http://docs.scala-lang.org/style/scaladoc.html}}, an improved Scala version of Javadoc
\end{itemize}
}

\frame{
\frametitle{Data structures and parallellism}
\begin{itemize}
\item Scala has an extensive ``Collections framework" (\alert{\url{http://docs.scala-lang.org/overviews/collections/overview.html}}), providing a large range of data structures for almost any task (Array, List, Vector, Map, Range, Stream, Queue, Stack, ...)
\item Most collections available as either a \alert{mutable} or \alert{immutable} version --- idiomatic Scala code favours immutable collections
\item Most collections have an associated \alert{parallel} version, providing concurrency and parallelism ``for free" (examples later)
\end{itemize}
}

\subsection{Functional programming}

\frame{
\frametitle{Functional approaches to concurrency and parallelisation}
\begin{itemize}
\item Functional languages emphasise immutable state and referentially transparent functions
\item \alert{Immutable state}, and \alert{referentially transparent} (\alert{side-effect} free) declarative workflow patterns are widely used for systems which really need to scale (leads to naturally parallel code)
\item \alert{Shared mutable state} is the enemy of concurrency and parallelism (synchronisation, locks, waits, deadlocks, race conditions, ...) --- by avoiding \alert{mutable state}, code becomes easy to parallelise 
\item The recent resurgence of functional programming and functional programming languages is partly driven by the realisation that functional programming provides a natural way to develop algorithms which can exploit multi-core parallel and distributed architectures, and efficiently scale
\end{itemize}
}

\frame{
\frametitle{Category theory}
Dummies guide:
\begin{itemize}
\item A ``collection" (or parametrised ``container" type) together with a ``map" function (defined in a sensible way) represents a \alert{functor}
\item If the collection additionally supports a (sensible) ``apply" operation, it is an \alert{applicative}
\item If the collection additionally supports a (sensible) ``flattening" operation, it is a \alert{monad} (required for composition)
\item For a ``reduce" operation on a collection to parallellise cleanly, the type of the collection together with the reduction operation must define a \alert{monoid} (must be an \alert{associative} operation, so that reductions can proceed in multiple threads in parallel)
\end{itemize}

}


\frame{
\frametitle{Scala ecosystem}
{\small\begin{itemize}
\item \alert{Akka} --- actor-based concurrency framework (inspired by Erlang)
\item \alert{Spark} --- scalable analytics library, including some ML (from Berkeley AMP Lab)
\item \alert{Algebird} --- abstract algebra (monoid) support library (from Twitter)
\item \alert{Scalding} --- cascading workflow library (from Twitter)
\item \alert{Storm} --- streaming analytics library (from Twitter)
\item \alert{Scalaz} --- category theory types (functors, monads, etc.)
\item \alert{Breeze} --- scientific and numerical library (including nonuniform random number generation and numerical linear algebra)
\item \alert{Saddle} --- data library (data frames, etc.)
\end{itemize}}
Large ecosystem of software libraries and developers using Scala in the big data space...
}

\section{Examples}

\subsection{Monte Carlo}

\frame{
\frametitle{Example: Monte Carlo}
\begin{itemize}
\item blah
\end{itemize}
}


\begin{frame}[fragile]
\frametitle{Parallel Monte Carlo integral in Scala}
{\scriptsize
\begin{lstlisting}[language=java]
object MonteCarlo {
  @tailrec
  def sum(its: Long,acc: Double): Double = {
    if (its==0) 
      (acc)
    else {
      val u=ThreadLocalRandom.current().nextDouble()
      sum(its-1,acc+exp(-u*u))
    }
  }
  def main(args: Array[String]) = {
    val N=args(0).toInt
    val iters=1000000000
    val its=iters/N
    val sums=(1 to N).toList.par map {x => sum(its,0.0)}
    val result=sums.reduce(_+_)
    println(result/iters)
  }
}
\end{lstlisting}
}
Actually runs \alert{faster} than the C+MPI version...
\end{frame}

\subsection{Linear regression}

\frame{
\frametitle{Example: linear regression}
\begin{itemize}
\item blah
\end{itemize}
}

\frame{
\frametitle{blah}
\begin{itemize}
\item blah
\end{itemize}
}





\subsection{Summary and further pointers}

\frame{
\frametitle{Summary}
\begin{itemize}
\item Strong arguments can be made that a language to be used as a platform for statistical computing should be general purpose, platform independent, functional, statically typed and compiled
\item For basic exploratory data analysis, visualisation and model fitting, R works perfectly well (currently better than Scala)
\item Scala is worth considering if you are interested in any of the following:
  \begin{itemize}
  \item Writing your own statistical routines or algorithms
  \item Working with computationally intensive (parallel) algorithms
  \item Working with large and complex models for which an out-of-the-box solution doesn't exist in R
  \item Working with large data sets (big data)
  \item Integrating statistical analysis workflow with other system components (including web infrastructure, relational databases, no-sql databases, etc.)
  \end{itemize}
\end{itemize}
}


\frame{
\frametitle{Links and further reading}
\begin{itemize}
\item Scala: \alert{\url{http://www.scala-lang.org/}}
\item Scala on wikipedia: \alert{\url{http://en.wikipedia.org/wiki/Scala_(programming_language)}}
\item My blog: \alert{\url{http://darrenjw.wordpress.com/}}
  \begin{itemize}
  \item \href{http://darrenjw.wordpress.com/2013/12/23/scala-as-a-platform-for-statistical-computing-and-data-science/}{Scala as a platform for statistical computing and data science}
  \item \href{http://darrenjw.wordpress.com/2013/12/30/brief-introduction-to-scala-and-breeze-for-statistical-computing/}{Brief introduction to Scala and Breeze for statistical computing}
  \item \href{http://darrenjw.wordpress.com/2013/10/04/a-functional-gibbs-sampler-in-scala/}{A functional Gibbs sampler in Scala}
  \item \href{http://darrenjw.wordpress.com/2014/02/23/parallel-monte-carlo-using-scala/}{Parallel Monte Carlo using Scala}
  \end{itemize}
\item This talk and code examples: \alert{\url{https://github.com/darrenjw/statslang-scala}} (also merged into \alert{\url{https://github.com/csgillespie/statslang}})
\end{itemize}

}




\end{document}

